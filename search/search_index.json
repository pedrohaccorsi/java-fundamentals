{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Java Fundamentals! # This is an online trainning, in which we will discuss Java as a plataform for designing systems. By the end of this course you'll have solid understanding of: Java plataform Language JVM Standard Libraries Useful links # TBD","title":"Home"},{"location":"#welcome-to-java-fundamentals","text":"This is an online trainning, in which we will discuss Java as a plataform for designing systems. By the end of this course you'll have solid understanding of: Java plataform Language JVM Standard Libraries","title":"Welcome to Java Fundamentals!"},{"location":"#useful-links","text":"TBD","title":"Useful links"},{"location":"beginer/java-big-picture/compile-run/readme/","text":"Compiling and Running # Consider the code below. First we have a class declaration, where we declare the class Hello . Then, we implement the method public static void main(String[] args) . This method simply prints to the console the text Hello, Superprof! . Compiling into java bytecode # Now that we have our code, we must compile it into java bytecode, so that the JVM can later process it. This compilation is done with the command javac followed by the class we want to compile, in our case Hello.java . The output of this command ( javac Hello.java ) is a new file called Hello.class , that is the bytecode of class Hello. Running with java virtual machine # Finally, we send this bytecode into the JVM with the command java followed by the compiled bytecode name, Hello . This command will trigger JVM which will convert our bytecode to machine code, and have it processed by the CPU. Conclusion # The Java compilation and running process can be condensed by the image below, where we declare a Hello.java compile it with javac Hello.java run it with java Hello From it, we can understand why java is a write once, run anywhere language, since the actual conversion to machine code isn't made by the compiler itself, but by an entire runtime environemt (JRE) that is client-specific.","title":"Compiling and Running"},{"location":"beginer/java-big-picture/compile-run/readme/#compiling-and-running","text":"Consider the code below. First we have a class declaration, where we declare the class Hello . Then, we implement the method public static void main(String[] args) . This method simply prints to the console the text Hello, Superprof! .","title":"Compiling and Running"},{"location":"beginer/java-big-picture/compile-run/readme/#compiling-into-java-bytecode","text":"Now that we have our code, we must compile it into java bytecode, so that the JVM can later process it. This compilation is done with the command javac followed by the class we want to compile, in our case Hello.java . The output of this command ( javac Hello.java ) is a new file called Hello.class , that is the bytecode of class Hello.","title":"Compiling into java bytecode"},{"location":"beginer/java-big-picture/compile-run/readme/#running-with-java-virtual-machine","text":"Finally, we send this bytecode into the JVM with the command java followed by the compiled bytecode name, Hello . This command will trigger JVM which will convert our bytecode to machine code, and have it processed by the CPU.","title":"Running with java virtual machine"},{"location":"beginer/java-big-picture/compile-run/readme/#conclusion","text":"The Java compilation and running process can be condensed by the image below, where we declare a Hello.java compile it with javac Hello.java run it with java Hello From it, we can understand why java is a write once, run anywhere language, since the actual conversion to machine code isn't made by the compiler itself, but by an entire runtime environemt (JRE) that is client-specific.","title":"Conclusion"},{"location":"beginer/java-big-picture/plataform/readme/","text":"Plataform # Java itself is composed by three big things: programming language runtime environment standard library When one refers to Java, they might be refering to either one of these three, or to the whole. These three parts of the Java plataform are bundled together into the JDK: Java Development Kit . This means that the base architecture of a Java application consists in the following blocks: Aplication source code # The application source code is where we, developers, come in. We write our code with the java programming language . Here we apply the Java syntax to solve any given problem. Appication bytecode # With our code code, we now compile it into bytecode. This is an intermediary state of our code, which is yet not readable by the CPU. Here, our code is put together with 3 rd -party libraries we are using. Java Standard Edition (SE) APIs # Finally, Java adds the bytecode of the standard functions we are using, such as System.out or things like that. Once this is done, we finally have the bytecode of our entire application. Java Virtual Machine # Here is the final step. JVM is responsible to convert our bytecode application into CPU readable code (most likely assembly for a given processor architecture), which is then executed by the hardware. Conclusion # Java is a powerful language that bring apps to live due to is big environment. Also, it facilitates cross-plataform code, since developers compile any Java code into bytecode, that is latter processed by the user-specific JVM. In other words, Java is such a gigantic and commonly accepted plataform because developers can safely rely on stable 3 rd party libraries, stable JVM's to different processors, easy language ramp-up, along with many other points.","title":"Plataform"},{"location":"beginer/java-big-picture/plataform/readme/#plataform","text":"Java itself is composed by three big things: programming language runtime environment standard library When one refers to Java, they might be refering to either one of these three, or to the whole. These three parts of the Java plataform are bundled together into the JDK: Java Development Kit . This means that the base architecture of a Java application consists in the following blocks:","title":"Plataform"},{"location":"beginer/java-big-picture/plataform/readme/#aplication-source-code","text":"The application source code is where we, developers, come in. We write our code with the java programming language . Here we apply the Java syntax to solve any given problem.","title":"Aplication source code"},{"location":"beginer/java-big-picture/plataform/readme/#appication-bytecode","text":"With our code code, we now compile it into bytecode. This is an intermediary state of our code, which is yet not readable by the CPU. Here, our code is put together with 3 rd -party libraries we are using.","title":"Appication bytecode"},{"location":"beginer/java-big-picture/plataform/readme/#java-standard-edition-se-apis","text":"Finally, Java adds the bytecode of the standard functions we are using, such as System.out or things like that. Once this is done, we finally have the bytecode of our entire application.","title":"Java Standard Edition (SE) APIs"},{"location":"beginer/java-big-picture/plataform/readme/#java-virtual-machine","text":"Here is the final step. JVM is responsible to convert our bytecode application into CPU readable code (most likely assembly for a given processor architecture), which is then executed by the hardware.","title":"Java Virtual Machine"},{"location":"beginer/java-big-picture/plataform/readme/#conclusion","text":"Java is a powerful language that bring apps to live due to is big environment. Also, it facilitates cross-plataform code, since developers compile any Java code into bytecode, that is latter processed by the user-specific JVM. In other words, Java is such a gigantic and commonly accepted plataform because developers can safely rely on stable 3 rd party libraries, stable JVM's to different processors, easy language ramp-up, along with many other points.","title":"Conclusion"}]}